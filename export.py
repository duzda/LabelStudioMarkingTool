#!/usr/bin/python3

import os
import json
import argparse
from typing import TypedDict, List, Dict, Optional

# ===== JSON TYPES =====

Value = TypedDict('value', {
    "start": int,
    "end": int,
    "text": str,
    "labels": List[str]
})

Meta = TypedDict('meta', {
    "text": Optional[List[str]]
})

Result = TypedDict('result', {
    "value": Value,
    "meta": Optional[Meta],
    "id": str,
    "from_name": str,
    "to_name": str,
    "type": str,
    "origin": str
})

Annotation = TypedDict('annotation', {
    "id": int,
    "completed_by": int,
    "result": List[Result],
    "was_cancelled": bool,
    "ground_truth": bool,
    "created_at": str,
    "updated_at": str,
    "draft_created_at": str,
    "lead_time": float,
    "prediction": any,
    "result_count": int,
    "unique_id": str,
    "import_id": any,
    "last_action": any,
    "task": int,
    "project": int,
    "updated_by": int,
    "parent_prediction": any,
    "parent_annotation": any,
    "last_created_by": any
})

Data = TypedDict("data", {
    "ids": str,
    "text": str,
    "source": str
})
 
Task = TypedDict('Task', {
    "id": int,
    "annotations": List[Annotation],
    "file_upload": str,
    "drafts": List[any],
    "predictions": List[any],
    "data": Data,
    "meta": Dict[any, any],
    "created_at": str,
    "updated_at": str,
    "inner_id": int,
    "total_annotations": int,
    "cancelled_annotations": int,
    "total_predictions": int,
    "comment_count": int,
    "unresolved_comment_count": int,
    "last_comment_updated_at": any,
    "project": int,
    "updated_by": int,
    "comment_authors": List[any] 
})

# ===== PROGRAM =====

def init_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-i', '--input', nargs='?', required=True, help='Input json, should be generated by Label Studio')
    parser.add_argument('-o', '--output', nargs='?', required=True, help='Name of the output file')

    args = parser.parse_args()

    if not os.path.isfile(args.input):
        raise Exception("Input doesn't exist or is a path")

    return args


def load_json(path: str) -> List[Task]:
    with open(path) as file:
        return json.load(file)


def get_parsed_text(task: Task) -> str:
    translation = task["data"]["text"]
    result_translation = ""
    start_list: List[Result] = []
    end_stack: List[int] = []

    for annotation in task["annotations"]:
        for result in annotation["result"]:
            start_list.append(result)
            end_stack.append(result["value"]["end"])

        start_list.sort(key = lambda r: r["value"]["start"])
        end_stack.sort()

    for i in range(len(translation)):
        if len(start_list) > 0 and i == start_list[0]["value"]["start"]:
            result = start_list.pop(0)

            result_translation += "<error"
            for label in result["value"]["labels"]:
                result_translation += " type=\"" + label + "\""
            if "meta" in result and "text" in result["meta"]:
                result_translation += " correction=\"" + result["meta"]["text"][0] + "\""
            result_translation += ">"

        if len(end_stack) > 0 and i == end_stack[0]:
            result_translation += "</error>"
            end_stack.pop(0)

        result_translation += translation[i]

    output = ""
    lines = result_translation.split("\n")
    ids = task["data"]["ids"].split("\n")

    for i in range(min(len(lines), len(ids))):
        output += ids[i] + "\t" + lines[i] + "\n"

    return output


def main(input: str, output: str) -> None:
    task_list = load_json(input)
    with open(output, "w") as file:
        for task in task_list:
            file.write(get_parsed_text(task))


if __name__ == "__main__": 
    args = init_args()
    main(args.input, args.output)
